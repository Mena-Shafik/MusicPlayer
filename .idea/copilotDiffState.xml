<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/musicplayer/service/PlayerForegroundService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/musicplayer/service/PlayerForegroundService.kt" />
              <option name="originalContent" value="package com.example.musicplayer.service&#10;&#10;import android.app.Service&#10;import android.content.Intent&#10;import android.media.AudioAttributes&#10;import android.media.MediaPlayer&#10;import android.os.Binder&#10;import android.os.IBinder&#10;import android.util.Log&#10;import androidx.media.session.MediaButtonReceiver&#10;import android.support.v4.media.session.MediaSessionCompat&#10;import android.support.v4.media.MediaMetadataCompat&#10;import android.support.v4.media.session.PlaybackStateCompat&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;import android.graphics.Bitmap&#10;import com.example.musicplayer.Util&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.net.toUri&#10;&#10;class PlayerForegroundService : Service() {&#10;    private val TAG = &quot;PlayerFgService&quot;&#10;    private var mediaSession: MediaSessionCompat? = null&#10;    private val binder = Binder()&#10;&#10;    private var mediaPlayer: MediaPlayer? = null&#10;    private val scope = CoroutineScope(Dispatchers.Main + Job())&#10;    private var pollJob: Job? = null&#10;    private var currentArtwork: Bitmap? = null&#10;    // track which playlist index is currently loaded/prepared in the mediaPlayer&#10;    private var currentPreparedIndex: Int = -1&#10;    // track last time we updated the notification (ms) to avoid excessive updates&#10;    private var lastNotificationUpdateTime: Long = 0L&#10;    // track which playlist index and path is currently loaded/prepared in the mediaPlayer&#10;    private var currentPreparedPath: String? = null&#10;    // whether we've called startForeground already (to satisfy startForegroundService requirement)&#10;    private var isForegroundStarted: Boolean = false&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        // Ensure notification channel exists and promote to foreground immediately with a minimal notification.&#10;        try {&#10;            PlayerNotificationManager.ensureChannel(this)&#10;            if (!isForegroundStarted) {&#10;                val minimal = NotificationCompat.Builder(this, &quot;music_player_channel&quot;)&#10;                    .setSmallIcon(com.example.musicplayer.R.drawable.ic_music_note)&#10;                    .setContentTitle(&quot;Music Player&quot;)&#10;                    .setContentText(&quot;&quot;)&#10;                    .setPriority(NotificationCompat.PRIORITY_LOW)&#10;                    .setOngoing(true)&#10;                    .build()&#10;                startForeground(PlayerNotificationManager.NOTIFICATION_ID, minimal)&#10;                isForegroundStarted = true&#10;                Log.d(TAG, &quot;onCreate: started immediate minimal foreground notification&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;onCreate: failed to start immediate foreground notification: ${e.message}&quot;)&#10;        }&#10;        mediaSession = MediaSessionCompat(this, &quot;PlayerService&quot;).apply {&#10;            setCallback(object : MediaSessionCompat.Callback() {&#10;                override fun onPlay() {&#10;                    // start playback&#10;                    this@PlayerForegroundService.playInternal()&#10;                }&#10;&#10;                override fun onPause() {&#10;                    this@PlayerForegroundService.pauseInternal()&#10;                }&#10;&#10;                override fun onSkipToNext() {&#10;                    this@PlayerForegroundService.nextInternal()&#10;                }&#10;&#10;                override fun onSkipToPrevious() {&#10;                    this@PlayerForegroundService.prevInternal()&#10;                }&#10;&#10;                override fun onSeekTo(pos: Long) {&#10;                    this@PlayerForegroundService.seekInternal(pos)&#10;                }&#10;            })&#10;        }&#10;        mediaSession?.isActive = true&#10;&#10;        // initialize player&#10;        mediaPlayer = MediaPlayer().apply {&#10;            setAudioAttributes(&#10;                AudioAttributes.Builder().setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)&#10;                    .setUsage(AudioAttributes.USAGE_MEDIA).build()&#10;            )&#10;            setOnCompletionListener {&#10;                // when track completes, move to next&#10;                nextInternal()&#10;            }&#10;            setOnPreparedListener { mp -&gt;&#10;                try {&#10;                    val d = try { mp.duration.toLong() } catch (_: Throwable) { 0L }&#10;                    PlayerRepository.setDurationMs(d)&#10;                    mp.start()&#10;                    PlayerRepository.setIsPlaying(true)&#10;                    updatePlaybackState(PlaybackStateCompat.STATE_PLAYING)&#10;                    startForegroundNotification()&#10;                } catch (_: Throwable) { }&#10;            }&#10;        }&#10;&#10;        // Ensure we enter foreground promptly to satisfy startForegroundService timing.&#10;        // Use a lightweight notification here; it will be updated later when playback starts.&#10;        try {&#10;            if (!isForegroundStarted) {&#10;                Log.d(TAG, &quot;onCreate: starting lightweight foreground notification&quot;)&#10;                startForegroundNotification()&#10;                isForegroundStarted = true&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;onCreate: startForegroundNotification failed: ${e.message}&quot;)&#10;        }&#10;&#10;        // start position polling&#10;        startPolling()&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder = binder&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        // As an additional safeguard, if for any reason we didn't call startForeground in onCreate,&#10;        // ensure we promote to foreground immediately here (this must be fast).&#10;        if (!isForegroundStarted) {&#10;            try {&#10;                PlayerNotificationManager.ensureChannel(this)&#10;                val minimal = NotificationCompat.Builder(this, &quot;music_player_channel&quot;)&#10;                    .setSmallIcon(com.example.musicplayer.R.drawable.ic_music_note)&#10;                    .setContentTitle(&quot;Music Player&quot;)&#10;                    .setContentText(&quot;&quot;)&#10;                    .setPriority(NotificationCompat.PRIORITY_LOW)&#10;                    .setOngoing(true)&#10;                    .build()&#10;                startForeground(PlayerNotificationManager.NOTIFICATION_ID, minimal)&#10;                isForegroundStarted = true&#10;                Log.d(TAG, &quot;onStartCommand: started minimal foreground notification (safeguard)&quot;)&#10;            } catch (e: Exception) {&#10;                Log.w(TAG, &quot;onStartCommand: failed to start minimal foreground notification: ${e.message}&quot;)&#10;                // Fallback: attempt a minimal notification using the channel-aware constructor (works on all API levels in this project)&#10;                try {&#10;                    val minimal = NotificationCompat.Builder(this, &quot;music_player_channel&quot;)&#10;                        .setSmallIcon(com.example.musicplayer.R.drawable.ic_music_note)&#10;                        .setContentTitle(&quot;Music Player&quot;)&#10;                        .setContentText(&quot;&quot;)&#10;                        .setPriority(NotificationCompat.PRIORITY_LOW)&#10;                        .setOngoing(true)&#10;                        .build()&#10;                    startForeground(PlayerNotificationManager.NOTIFICATION_ID, minimal)&#10;                    isForegroundStarted = true&#10;                    Log.d(TAG, &quot;onStartCommand: started minimal foreground notification via fallback (channel-aware)&quot;)&#10;                } catch (_: Throwable) { }&#10;            }&#10;        }&#10;        val i = intent ?: return START_STICKY&#10;        val action = i.action&#10;        Log.d(TAG, &quot;onStartCommand action=$action | currentIndex=${PlayerRepository.currentIndex.value} preparedIndex=$currentPreparedIndex isPlaying=${PlayerRepository.isPlaying.value}&quot;)&#10;&#10;        // If this service was started with startForegroundService(), we must call startForeground() quickly.&#10;        // Call a lightweight notification immediately on play/prepare/update so the system won't kill the service.&#10;        try {&#10;            if (!isForegroundStarted &amp;&amp; (action == PlayerActions.ACTION_PLAY || action == PlayerActions.ACTION_PREPARE || action == PlayerActions.ACTION_UPDATE)) {&#10;                Log.d(TAG, &quot;Starting foreground with a lightweight notification to satisfy startForegroundService timing&quot;)&#10;                try {&#10;                    startForegroundNotification()&#10;                    isForegroundStarted = true&#10;                } catch (e: Exception) {&#10;                    Log.w(TAG, &quot;startForegroundNotification immediate failed: ${e.message}&quot;)&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Error while ensuring foreground start: ${e.message}&quot;)&#10;        }&#10;&#10;        when (action) {&#10;            PlayerActions.ACTION_PLAY -&gt; playInternal()&#10;            PlayerActions.ACTION_PAUSE -&gt; {&#10;                val suppress = i.getBooleanExtra(PlayerActions.EXTRA_SUPPRESS_NOTIFICATION, false)&#10;                pauseInternal(suppress)&#10;            }&#10;            PlayerActions.ACTION_NEXT -&gt; nextInternal()&#10;            PlayerActions.ACTION_PREV -&gt; prevInternal()&#10;            PlayerActions.ACTION_STOP -&gt; stopSelf()&#10;            PlayerActions.ACTION_SEEK -&gt; {&#10;                val pos = i.getLongExtra(PlayerActions.EXTRA_SEEK_POSITION, 0L)&#10;                seekInternal(pos)&#10;            }&#10;            PlayerActions.ACTION_PREPARE -&gt; {&#10;                // prepare current item without auto-starting&#10;                prepareCurrent(startPlaying = false)&#10;            }&#10;            PlayerActions.ACTION_UPDATE -&gt; {&#10;                val title = i.getStringExtra(PlayerActions.EXTRA_SONG_TITLE) ?: &quot;&quot;&#10;                val artist = i.getStringExtra(PlayerActions.EXTRA_SONG_ARTIST) ?: &quot;&quot;&#10;                updateMetadata(title, artist)&#10;                val isPlaying = i.getBooleanExtra(PlayerActions.EXTRA_IS_PLAYING, false)&#10;                updatePlaybackState(if (isPlaying) PlaybackStateCompat.STATE_PLAYING else PlaybackStateCompat.STATE_PAUSED)&#10;            }&#10;            PlayerActions.ACTION_SEEK_FORWARD -&gt; {&#10;                // advance by SEEK_STEP_MS&#10;                val cur = PlayerRepository.positionMs.value&#10;                val dur = PlayerRepository.durationMs.value&#10;                val target = (cur + PlayerActions.SEEK_STEP_MS).coerceAtMost(if (dur &gt; 0L) dur else Long.MAX_VALUE)&#10;                seekInternal(target)&#10;            }&#10;            PlayerActions.ACTION_SEEK_BACK -&gt; {&#10;                val cur = PlayerRepository.positionMs.value&#10;                val target = (cur - PlayerActions.SEEK_STEP_MS).coerceAtLeast(0L)&#10;                seekInternal(target)&#10;            }&#10;            Intent.ACTION_MEDIA_BUTTON -&gt; MediaButtonReceiver.handleIntent(mediaSession, i)&#10;            else -&gt; {&#10;                // unhandled action; ignore&#10;            }&#10;        }&#10;&#10;        return START_STICKY&#10;    }&#10;&#10;    private fun prepareCurrent(startPlaying: Boolean = true) {&#10;        val songs = PlayerRepository.playlist.value&#10;        if (songs.isEmpty()) return&#10;        val idx = PlayerRepository.currentIndex.value.coerceIn(0, songs.size - 1)&#10;        val song = songs.getOrNull(idx) ?: return&#10;        try {&#10;            Log.d(TAG, &quot;prepareCurrent requested idx=$idx path=${song.path}&quot;)&#10;            mediaPlayer?.reset()&#10;            // Use the correct setDataSource overload depending on path format.&#10;            try {&#10;                val p = song.path&#10;                if (p.startsWith(&quot;content://&quot;) || p.startsWith(&quot;file://&quot;) || p.startsWith(&quot;http://&quot;) || p.startsWith(&quot;https://&quot;)) {&#10;                    // content URIs and http(s) - use context/Uri overload&#10;                    mediaPlayer?.setDataSource(this@PlayerForegroundService, p.toUri())&#10;                } else {&#10;                    // plain file path&#10;                    mediaPlayer?.setDataSource(p)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.w(TAG, &quot;setDataSource failed for path=${song.path}, error=${e.message}&quot;)&#10;                // fallback: try setDataSource with raw path&#10;                try {&#10;                    mediaPlayer?.setDataSource(song.path)&#10;                } catch (ex: Exception) {&#10;                    Log.w(TAG, &quot;fallback setDataSource also failed: ${ex.message}&quot;)&#10;                    throw e&#10;                }&#10;            }&#10;            Log.d(TAG, &quot;setDataSource succeeded for idx=$idx&quot;)&#10;            // update metadata immediately&#10;            updateMetadata(song.title, song.artist)&#10;            // fetch album art asynchronously so we don't block service startup/main thread&#10;            try {&#10;                val artPath = song.path&#10;                // Launch IO work to extract embedded artwork (may use MediaMetadataRetriever)&#10;                scope.launch(Dispatchers.IO) {&#10;                    try {&#10;                        val art = try {&#10;                            Util.getThumbnail(this@PlayerForegroundService, artPath.toUri())&#10;                        } catch (_: Throwable) { null }&#10;                        if (art != null) {&#10;                            currentArtwork = art&#10;                            // update the ongoing notification with artwork on the main thread&#10;                            launch(Dispatchers.Main) { try { updateNotificationFromSession() } catch (_: Throwable) {} }&#10;                        }&#10;                    } catch (_: Throwable) { /* ignore */ }&#10;                }&#10;            } catch (_: Throwable) { currentArtwork = null }&#10;            // mark prepared index/path so playInternal can decide whether reload is needed&#10;            currentPreparedIndex = idx&#10;            currentPreparedPath = song.path&#10;            // prepare async and start when prepared if requested&#10;            mediaPlayer?.prepareAsync()&#10;            if (!startPlaying) {&#10;                // onPrepared will not auto-start in this branch; we can pause after prepared&#10;                // but simpler: we'll let onPrepared start, then pause if !startPlaying&#10;                // So schedule a short job to pause once prepared if necessary&#10;                scope.launch {&#10;                    // wait until prepared (duration &gt; 0) or timeout&#10;                    var waited = 0&#10;                    while (PlayerRepository.durationMs.value == 0L &amp;&amp; waited &lt; 5000) {&#10;                        delay(100)&#10;                        waited += 100&#10;                    }&#10;                    if (!startPlaying) {&#10;                        try { mediaPlayer?.pause() } catch (_: Throwable) {}&#10;                    }&#10;                }&#10;            }&#10;            PlayerRepository.setCurrentIndex(idx)&#10;            Log.d(TAG, &quot;prepareCurrent scheduled prepareAsync for idx=$idx (startPlaying=$startPlaying)&quot;)&#10;        } catch (_: Throwable) {&#10;            Log.w(TAG, &quot;prepareCurrent failed for idx=$idx&quot;)&#10;        }&#10;    }&#10;&#10;    private fun playInternal() {&#10;        try {&#10;            val desiredIdx = PlayerRepository.currentIndex.value&#10;            val desiredPath = PlayerRepository.playlist.value.getOrNull(desiredIdx)?.path&#10;            Log.d(TAG, &quot;playInternal called desiredIdx=$desiredIdx desiredPath=$desiredPath currentPreparedIndex=$currentPreparedIndex currentPreparedPath=$currentPreparedPath mediaPlaying=${mediaPlayer?.isPlaying}&quot;)&#10;            if (mediaPlayer?.isPlaying == true) {&#10;                // if already playing the requested path, nothing to do&#10;                if (currentPreparedPath != null &amp;&amp; currentPreparedPath == desiredPath) {&#10;                    Log.d(TAG, &quot;playInternal early-return: already playing desiredPath=$desiredPath&quot;)&#10;                    return&#10;                }&#10;                // otherwise we need to load the new index even while playing&#10;                Log.d(TAG, &quot;playInternal: preparedPath ($currentPreparedPath) != desiredPath ($desiredPath), reloading&quot;)&#10;            }&#10;            // if not prepared or different index, prepareCurrent will load the desired track&#10;            if (PlayerRepository.durationMs.value &lt;= 0L || currentPreparedIndex != desiredIdx) {&#10;                prepareCurrent(startPlaying = true)&#10;            } else {&#10;                mediaPlayer?.start()&#10;                PlayerRepository.setIsPlaying(true)&#10;                updatePlaybackState(PlaybackStateCompat.STATE_PLAYING)&#10;                startForegroundNotification()&#10;                Log.d(TAG, &quot;playInternal: started playback idx=$desiredIdx&quot;)&#10;            }&#10;        } catch (_: Throwable) {&#10;            Log.w(TAG, &quot;playInternal error&quot;)&#10;        }&#10;    }&#10;&#10;    private fun pauseInternal(suppressNotification: Boolean = false) {&#10;        try {&#10;            mediaPlayer?.pause()&#10;            PlayerRepository.setIsPlaying(false)&#10;            updatePlaybackState(PlaybackStateCompat.STATE_PAUSED)&#10;            if (suppressNotification) {&#10;                // user dismissed notification; cancel it and do not re-post&#10;                PlayerNotificationManager.cancel(this)&#10;                // stopForeground but keep service running (so playback remains paused and UI can resume)&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                try { stopForeground(STOP_FOREGROUND_DETACH) } catch (_: Throwable) {}&#10;            } else {&#10;                updateNotificationFromSession()&#10;            }&#10;        } catch (_: Throwable) {&#10;            Log.w(TAG, &quot;pauseInternal error&quot;)&#10;        }&#10;    }&#10;&#10;    private fun nextInternal() {&#10;        val songs = PlayerRepository.playlist.value&#10;        if (songs.isEmpty()) return&#10;        val nextIdx = PlayerRepository.nextIndex()&#10;        PlayerRepository.setCurrentIndex(nextIdx)&#10;        prepareCurrent(startPlaying = true)&#10;    }&#10;&#10;    private fun prevInternal() {&#10;        val songs = PlayerRepository.playlist.value&#10;        if (songs.isEmpty()) return&#10;        val prevIdx = PlayerRepository.prevIndex()&#10;        PlayerRepository.setCurrentIndex(prevIdx)&#10;        prepareCurrent(startPlaying = true)&#10;    }&#10;&#10;    private fun seekInternal(position: Long) {&#10;        try {&#10;            mediaPlayer?.seekTo(position.toInt())&#10;            PlayerRepository.setPositionMs(position)&#10;        } catch (_: Throwable) { }&#10;    }&#10;&#10;    private fun updatePlaybackState(state: Int, position: Long = PlayerRepository.positionMs.value) {&#10;        val playbackState = PlaybackStateCompat.Builder()&#10;            .setActions(&#10;                PlaybackStateCompat.ACTION_PLAY or&#10;                        PlaybackStateCompat.ACTION_PAUSE or&#10;                        PlaybackStateCompat.ACTION_PLAY_PAUSE or&#10;                        PlaybackStateCompat.ACTION_SKIP_TO_NEXT or&#10;                        PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS or&#10;                        PlaybackStateCompat.ACTION_SEEK_TO&#10;            )&#10;            .setState(state, position, if (state == PlaybackStateCompat.STATE_PLAYING) 1f else 0f)&#10;            .build()&#10;        mediaSession?.setPlaybackState(playbackState)&#10;        updateNotificationFromSession()&#10;    }&#10;&#10;    private fun updateMetadata(title: String, artist: String) {&#10;        val metadata = MediaMetadataCompat.Builder()&#10;            .putString(MediaMetadataCompat.METADATA_KEY_TITLE, title)&#10;            .putString(MediaMetadataCompat.METADATA_KEY_ARTIST, artist)&#10;            .build()&#10;        mediaSession?.setMetadata(metadata)&#10;        updateNotificationFromSession()&#10;    }&#10;&#10;    private fun startPolling() {&#10;        pollJob?.cancel()&#10;        pollJob = scope.launch {&#10;            while (isActive) {&#10;                try {&#10;                    val pos = mediaPlayer?.currentPosition?.toLong() ?: 0L&#10;                    val dur = mediaPlayer?.duration?.toLong() ?: PlayerRepository.durationMs.value&#10;                    PlayerRepository.setPositionMs(pos)&#10;                    if (dur &gt; 0) PlayerRepository.setDurationMs(dur)&#10;                    // Throttle notification updates to ~500ms to keep progress timely without spamming&#10;                    val now = System.currentTimeMillis()&#10;                    if (now - lastNotificationUpdateTime &gt;= 500L) {&#10;                        try { updateNotificationFromSession() } catch (_: Throwable) {}&#10;                        lastNotificationUpdateTime = now&#10;                    }&#10;                } catch (_: Throwable) {}&#10;                delay(200)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startForegroundNotification() {&#10;        val title = mediaSession?.controller?.metadata?.getString(MediaMetadataCompat.METADATA_KEY_TITLE) ?: &quot;Playing&quot;&#10;        val artist = mediaSession?.controller?.metadata?.getString(MediaMetadataCompat.METADATA_KEY_ARTIST) ?: &quot;&quot;&#10;        val isPlaying = mediaSession?.controller?.playbackState?.state == PlaybackStateCompat.STATE_PLAYING&#10;        val token = mediaSession?.sessionToken&#10;        val prog = PlayerRepository.positionMs.value&#10;        val max = PlayerRepository.durationMs.value&#10;        val notification = PlayerNotificationManager.buildNotification(&#10;            this,&#10;            title,&#10;            artist,&#10;            isPlaying,&#10;            currentArtwork,&#10;            true,&#10;            true,&#10;            token,&#10;            progressMs = prog,&#10;            durationMs = max&#10;        )&#10;        startForeground(PlayerNotificationManager.NOTIFICATION_ID, notification)&#10;    }&#10;&#10;    private fun updateNotificationFromSession() {&#10;        val title = mediaSession?.controller?.metadata?.getString(MediaMetadataCompat.METADATA_KEY_TITLE) ?: &quot;&quot;&#10;        val artist = mediaSession?.controller?.metadata?.getString(MediaMetadataCompat.METADATA_KEY_ARTIST) ?: &quot;&quot;&#10;        val isPlaying = mediaSession?.controller?.playbackState?.state == PlaybackStateCompat.STATE_PLAYING&#10;        val token = mediaSession?.sessionToken&#10;        val prog = PlayerRepository.positionMs.value&#10;        val max = PlayerRepository.durationMs.value&#10;        val notification = PlayerNotificationManager.buildNotification(&#10;            this,&#10;            title,&#10;            artist,&#10;            isPlaying,&#10;            currentArtwork,&#10;            true,&#10;            true,&#10;            token,&#10;            progressMs = prog,&#10;            durationMs = max&#10;        )&#10;        PlayerNotificationManager.postNotification(this, notification)&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        pollJob?.cancel()&#10;        try { mediaPlayer?.release() } catch (_: Throwable) {}&#10;        try { currentArtwork?.recycle() } catch (_: Throwable) {}&#10;        mediaSession?.release()&#10;        PlayerNotificationManager.cancel(this)&#10;    }&#10;&#10;    // When the app task is removed from Recents, stop playback and the service to honor the user's intent&#10;    override fun onTaskRemoved(rootIntent: Intent?) {&#10;        super.onTaskRemoved(rootIntent)&#10;        try {&#10;            Log.d(TAG, &quot;onTaskRemoved: app task removed, stopping service and playback&quot;)&#10;            // stop foreground and remove notification&#10;            try { stopForeground(STOP_FOREGROUND_REMOVE) } catch (_: Throwable) {}&#10;            // ensure media resources are released and service stopped&#10;            try { mediaPlayer?.stop() } catch (_: Throwable) {}&#10;            try { mediaPlayer?.release() } catch (_: Throwable) {}&#10;            PlayerRepository.setIsPlaying(false)&#10;            stopSelf()&#10;        } catch (_: Throwable) {&#10;            // best-effort cleanup&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.musicplayer.service&#10;&#10;import android.app.Service&#10;import android.content.Intent&#10;import android.media.AudioAttributes&#10;import android.media.MediaPlayer&#10;import android.os.Binder&#10;import android.os.IBinder&#10;import android.util.Log&#10;import androidx.media.session.MediaButtonReceiver&#10;import android.support.v4.media.session.MediaSessionCompat&#10;import android.support.v4.media.MediaMetadataCompat&#10;import android.support.v4.media.session.PlaybackStateCompat&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;import android.graphics.Bitmap&#10;import com.example.musicplayer.Util&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.net.toUri&#10;&#10;class PlayerForegroundService : Service() {&#10;    private val TAG = &quot;PlayerFgService&quot;&#10;    private var mediaSession: MediaSessionCompat? = null&#10;    private val binder = Binder()&#10;&#10;    private var mediaPlayer: MediaPlayer? = null&#10;    private val scope = CoroutineScope(Dispatchers.Main + Job())&#10;    private var pollJob: Job? = null&#10;    private var currentArtwork: Bitmap? = null&#10;    // track which playlist index is currently loaded/prepared in the mediaPlayer&#10;    private var currentPreparedIndex: Int = -1&#10;    // track last time we updated the notification (ms) to avoid excessive updates&#10;    private var lastNotificationUpdateTime: Long = 0L&#10;    // track which playlist index and path is currently loaded/prepared in the mediaPlayer&#10;    private var currentPreparedPath: String? = null&#10;    // whether we've called startForeground already (to satisfy startForegroundService requirement)&#10;    private var isForegroundStarted: Boolean = false&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        // Ensure notification channel exists and promote to foreground immediately with a minimal notification.&#10;        try {&#10;            PlayerNotificationManager.ensureChannel(this)&#10;            if (!isForegroundStarted) {&#10;                val minimal = NotificationCompat.Builder(this, &quot;music_player_channel&quot;)&#10;                    .setSmallIcon(com.example.musicplayer.R.drawable.ic_music_note)&#10;                    .setContentTitle(&quot;Music Player&quot;)&#10;                    .setContentText(&quot;&quot;)&#10;                    .setPriority(NotificationCompat.PRIORITY_LOW)&#10;                    .setOngoing(true)&#10;                    .build()&#10;                startForeground(PlayerNotificationManager.NOTIFICATION_ID, minimal)&#10;                isForegroundStarted = true&#10;                Log.d(TAG, &quot;onCreate: started immediate minimal foreground notification&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;onCreate: failed to start immediate foreground notification: ${e.message}&quot;)&#10;        }&#10;        mediaSession = MediaSessionCompat(this, &quot;PlayerService&quot;).apply {&#10;            setCallback(object : MediaSessionCompat.Callback() {&#10;                override fun onPlay() {&#10;                    // start playback&#10;                    this@PlayerForegroundService.playInternal()&#10;                }&#10;&#10;                override fun onPause() {&#10;                    this@PlayerForegroundService.pauseInternal()&#10;                }&#10;&#10;                override fun onSkipToNext() {&#10;                    this@PlayerForegroundService.nextInternal()&#10;                }&#10;&#10;                override fun onSkipToPrevious() {&#10;                    this@PlayerForegroundService.prevInternal()&#10;                }&#10;&#10;                override fun onSeekTo(pos: Long) {&#10;                    this@PlayerForegroundService.seekInternal(pos)&#10;                }&#10;            })&#10;        }&#10;        mediaSession?.isActive = true&#10;&#10;        // initialize player&#10;        mediaPlayer = MediaPlayer().apply {&#10;            setAudioAttributes(&#10;                AudioAttributes.Builder().setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)&#10;                    .setUsage(AudioAttributes.USAGE_MEDIA).build()&#10;            )&#10;            setOnCompletionListener {&#10;                // when track completes, move to next&#10;                nextInternal()&#10;            }&#10;            setOnPreparedListener { mp -&gt;&#10;                try {&#10;                    val d = try { mp.duration.toLong() } catch (_: Throwable) { 0L }&#10;                    PlayerRepository.setDurationMs(d)&#10;                    mp.start()&#10;                    PlayerRepository.setIsPlaying(true)&#10;                    updatePlaybackState(PlaybackStateCompat.STATE_PLAYING)&#10;                    startForegroundNotification()&#10;                } catch (_: Throwable) { }&#10;            }&#10;        }&#10;&#10;        // Ensure we enter foreground promptly to satisfy startForegroundService timing.&#10;        // Use a lightweight notification here; it will be updated later when playback starts.&#10;        try {&#10;            if (!isForegroundStarted) {&#10;                Log.d(TAG, &quot;onCreate: starting lightweight foreground notification&quot;)&#10;                startForegroundNotification()&#10;                isForegroundStarted = true&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;onCreate: startForegroundNotification failed: ${e.message}&quot;)&#10;        }&#10;&#10;        // start position polling&#10;        startPolling()&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder = binder&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        // As an additional safeguard, if for any reason we didn't call startForeground in onCreate,&#10;        // ensure we promote to foreground immediately here (this must be fast).&#10;        if (!isForegroundStarted) {&#10;            try {&#10;                PlayerNotificationManager.ensureChannel(this)&#10;                val minimal = NotificationCompat.Builder(this, &quot;music_player_channel&quot;)&#10;                    .setSmallIcon(com.example.musicplayer.R.drawable.ic_music_note)&#10;                    .setContentTitle(&quot;Music Player&quot;)&#10;                    .setContentText(&quot;&quot;)&#10;                    .setPriority(NotificationCompat.PRIORITY_LOW)&#10;                    .setOngoing(true)&#10;                    .build()&#10;                startForeground(PlayerNotificationManager.NOTIFICATION_ID, minimal)&#10;                isForegroundStarted = true&#10;                Log.d(TAG, &quot;onStartCommand: started minimal foreground notification (safeguard)&quot;)&#10;            } catch (e: Exception) {&#10;                Log.w(TAG, &quot;onStartCommand: failed to start minimal foreground notification: ${e.message}&quot;)&#10;                // Fallback: attempt a minimal notification using the channel-aware constructor (works on all API levels in this project)&#10;                try {&#10;                    val minimal = NotificationCompat.Builder(this, &quot;music_player_channel&quot;)&#10;                        .setSmallIcon(com.example.musicplayer.R.drawable.ic_music_note)&#10;                        .setContentTitle(&quot;Music Player&quot;)&#10;                        .setContentText(&quot;&quot;)&#10;                        .setPriority(NotificationCompat.PRIORITY_LOW)&#10;                        .setOngoing(true)&#10;                        .build()&#10;                    startForeground(PlayerNotificationManager.NOTIFICATION_ID, minimal)&#10;                    isForegroundStarted = true&#10;                    Log.d(TAG, &quot;onStartCommand: started minimal foreground notification via fallback (channel-aware)&quot;)&#10;                } catch (_: Throwable) { }&#10;            }&#10;        }&#10;        val i = intent ?: return START_STICKY&#10;        val action = i.action&#10;        Log.d(TAG, &quot;onStartCommand action=$action | currentIndex=${PlayerRepository.currentIndex.value} preparedIndex=$currentPreparedIndex isPlaying=${PlayerRepository.isPlaying.value}&quot;)&#10;&#10;        // If this service was started with startForegroundService(), we must call startForeground() quickly.&#10;        // Call a lightweight notification immediately on play/prepare/update so the system won't kill the service.&#10;        try {&#10;            if (!isForegroundStarted &amp;&amp; (action == PlayerActions.ACTION_PLAY || action == PlayerActions.ACTION_PREPARE || action == PlayerActions.ACTION_UPDATE)) {&#10;                Log.d(TAG, &quot;Starting foreground with a lightweight notification to satisfy startForegroundService timing&quot;)&#10;                try {&#10;                    startForegroundNotification()&#10;                    isForegroundStarted = true&#10;                } catch (e: Exception) {&#10;                    Log.w(TAG, &quot;startForegroundNotification immediate failed: ${e.message}&quot;)&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Error while ensuring foreground start: ${e.message}&quot;)&#10;        }&#10;&#10;        when (action) {&#10;            PlayerActions.ACTION_PLAY -&gt; playInternal()&#10;            PlayerActions.ACTION_PAUSE -&gt; {&#10;                val suppress = i.getBooleanExtra(PlayerActions.EXTRA_SUPPRESS_NOTIFICATION, false)&#10;                pauseInternal(suppress)&#10;            }&#10;            PlayerActions.ACTION_NEXT -&gt; nextInternal()&#10;            PlayerActions.ACTION_PREV -&gt; prevInternal()&#10;            PlayerActions.ACTION_STOP -&gt; stopSelf()&#10;            PlayerActions.ACTION_SEEK -&gt; {&#10;                val pos = i.getLongExtra(PlayerActions.EXTRA_SEEK_POSITION, 0L)&#10;                seekInternal(pos)&#10;            }&#10;            PlayerActions.ACTION_PREPARE -&gt; {&#10;                // prepare current item without auto-starting&#10;                prepareCurrent(startPlaying = false)&#10;            }&#10;            PlayerActions.ACTION_UPDATE -&gt; {&#10;                val title = i.getStringExtra(PlayerActions.EXTRA_SONG_TITLE) ?: &quot;&quot;&#10;                val artist = i.getStringExtra(PlayerActions.EXTRA_SONG_ARTIST) ?: &quot;&quot;&#10;                updateMetadata(title, artist)&#10;                val isPlaying = i.getBooleanExtra(PlayerActions.EXTRA_IS_PLAYING, false)&#10;                updatePlaybackState(if (isPlaying) PlaybackStateCompat.STATE_PLAYING else PlaybackStateCompat.STATE_PAUSED)&#10;            }&#10;            PlayerActions.ACTION_SEEK_FORWARD -&gt; {&#10;                // advance by SEEK_STEP_MS&#10;                val cur = PlayerRepository.positionMs.value&#10;                val dur = PlayerRepository.durationMs.value&#10;                val target = (cur + PlayerActions.SEEK_STEP_MS).coerceAtMost(if (dur &gt; 0L) dur else Long.MAX_VALUE)&#10;                seekInternal(target)&#10;            }&#10;            PlayerActions.ACTION_SEEK_BACK -&gt; {&#10;                val cur = PlayerRepository.positionMs.value&#10;                val target = (cur - PlayerActions.SEEK_STEP_MS).coerceAtLeast(0L)&#10;                seekInternal(target)&#10;            }&#10;            Intent.ACTION_MEDIA_BUTTON -&gt; MediaButtonReceiver.handleIntent(mediaSession, i)&#10;            else -&gt; {&#10;                // unhandled action; ignore&#10;            }&#10;        }&#10;&#10;        return START_STICKY&#10;    }&#10;&#10;    private fun prepareCurrent(startPlaying: Boolean = true) {&#10;        val songs = PlayerRepository.playlist.value&#10;        if (songs.isEmpty()) return&#10;        val idx = PlayerRepository.currentIndex.value.coerceIn(0, songs.size - 1)&#10;        val song = songs.getOrNull(idx) ?: return&#10;        try {&#10;            Log.d(TAG, &quot;prepareCurrent requested idx=$idx path=${song.path}&quot;)&#10;            mediaPlayer?.reset()&#10;            // Use the correct setDataSource overload depending on path format.&#10;            try {&#10;                val p = song.path&#10;                if (p.startsWith(&quot;content://&quot;) || p.startsWith(&quot;file://&quot;) || p.startsWith(&quot;http://&quot;) || p.startsWith(&quot;https://&quot;)) {&#10;                    // content URIs and http(s) - use context/Uri overload&#10;                    mediaPlayer?.setDataSource(this@PlayerForegroundService, p.toUri())&#10;                } else {&#10;                    // plain file path&#10;                    mediaPlayer?.setDataSource(p)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.w(TAG, &quot;setDataSource failed for path=${song.path}, error=${e.message}&quot;)&#10;                // fallback: try setDataSource with raw path&#10;                try {&#10;                    mediaPlayer?.setDataSource(song.path)&#10;                } catch (ex: Exception) {&#10;                    Log.w(TAG, &quot;fallback setDataSource also failed: ${ex.message}&quot;)&#10;                    throw e&#10;                }&#10;            }&#10;            Log.d(TAG, &quot;setDataSource succeeded for idx=$idx&quot;)&#10;            // update metadata immediately&#10;            updateMetadata(song.title, song.artist)&#10;            // fetch album art asynchronously so we don't block service startup/main thread&#10;            try {&#10;                val artPath = song.path&#10;                // Launch IO work to extract embedded artwork (may use MediaMetadataRetriever)&#10;                scope.launch(Dispatchers.IO) {&#10;                    try {&#10;                        val art = try {&#10;                            Util.getThumbnail(this@PlayerForegroundService, artPath.toUri())&#10;                        } catch (_: Throwable) { null }&#10;                        if (art != null) {&#10;                            currentArtwork = art&#10;                            // update the ongoing notification with artwork on the main thread&#10;                            launch(Dispatchers.Main) { try { updateNotificationFromSession() } catch (_: Throwable) {} }&#10;                        }&#10;                    } catch (_: Throwable) { /* ignore */ }&#10;                }&#10;            } catch (_: Throwable) { currentArtwork = null }&#10;            // mark prepared index/path so playInternal can decide whether reload is needed&#10;            currentPreparedIndex = idx&#10;            currentPreparedPath = song.path&#10;            // prepare async and start when prepared if requested&#10;            mediaPlayer?.prepareAsync()&#10;            if (!startPlaying) {&#10;                // onPrepared will not auto-start in this branch; we can pause after prepared&#10;                // but simpler: we'll let onPrepared start, then pause if !startPlaying&#10;                // So schedule a short job to pause once prepared if necessary&#10;                scope.launch {&#10;                    // wait until prepared (duration &gt; 0) or timeout&#10;                    var waited = 0&#10;                    while (PlayerRepository.durationMs.value == 0L &amp;&amp; waited &lt; 5000) {&#10;                        delay(100)&#10;                        waited += 100&#10;                    }&#10;                    if (!startPlaying) {&#10;                        try { mediaPlayer?.pause() } catch (_: Throwable) {}&#10;                    }&#10;                }&#10;            }&#10;            PlayerRepository.setCurrentIndex(idx)&#10;            Log.d(TAG, &quot;prepareCurrent scheduled prepareAsync for idx=$idx (startPlaying=$startPlaying)&quot;)&#10;        } catch (_: Throwable) {&#10;            Log.w(TAG, &quot;prepareCurrent failed for idx=$idx&quot;)&#10;        }&#10;    }&#10;&#10;    private fun playInternal() {&#10;        try {&#10;            val desiredIdx = PlayerRepository.currentIndex.value&#10;            val desiredPath = PlayerRepository.playlist.value.getOrNull(desiredIdx)?.path&#10;            Log.d(TAG, &quot;playInternal called desiredIdx=$desiredIdx desiredPath=$desiredPath currentPreparedIndex=$currentPreparedIndex currentPreparedPath=$currentPreparedPath mediaPlaying=${mediaPlayer?.isPlaying}&quot;)&#10;            if (mediaPlayer?.isPlaying == true) {&#10;                // if already playing the requested path, nothing to do&#10;                if (currentPreparedPath != null &amp;&amp; currentPreparedPath == desiredPath) {&#10;                    Log.d(TAG, &quot;playInternal early-return: already playing desiredPath=$desiredPath&quot;)&#10;                    return&#10;                }&#10;                // otherwise we need to load the new index even while playing&#10;                Log.d(TAG, &quot;playInternal: preparedPath ($currentPreparedPath) != desiredPath ($desiredPath), reloading&quot;)&#10;            }&#10;            // if not prepared or different index, prepareCurrent will load the desired track&#10;            if (PlayerRepository.durationMs.value &lt;= 0L || currentPreparedIndex != desiredIdx) {&#10;                prepareCurrent(startPlaying = true)&#10;            } else {&#10;                mediaPlayer?.start()&#10;                PlayerRepository.setIsPlaying(true)&#10;                updatePlaybackState(PlaybackStateCompat.STATE_PLAYING)&#10;                startForegroundNotification()&#10;                Log.d(TAG, &quot;playInternal: started playback idx=$desiredIdx&quot;)&#10;            }&#10;        } catch (_: Throwable) {&#10;            Log.w(TAG, &quot;playInternal error&quot;)&#10;        }&#10;    }&#10;&#10;    private fun pauseInternal(suppressNotification: Boolean = false) {&#10;        try {&#10;            mediaPlayer?.pause()&#10;            PlayerRepository.setIsPlaying(false)&#10;            updatePlaybackState(PlaybackStateCompat.STATE_PAUSED)&#10;            if (suppressNotification) {&#10;                // user dismissed notification; cancel it and do not re-post&#10;                PlayerNotificationManager.cancel(this)&#10;                // stopForeground but keep service running (so playback remains paused and UI can resume)&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                try { stopForeground(STOP_FOREGROUND_DETACH) } catch (_: Throwable) {}&#10;            } else {&#10;                updateNotificationFromSession()&#10;            }&#10;        } catch (_: Throwable) {&#10;            Log.w(TAG, &quot;pauseInternal error&quot;)&#10;        }&#10;    }&#10;&#10;    private fun nextInternal() {&#10;        val songs = PlayerRepository.playlist.value&#10;        if (songs.isEmpty()) return&#10;        val nextIdx = PlayerRepository.nextIndex()&#10;        PlayerRepository.setCurrentIndex(nextIdx)&#10;        prepareCurrent(startPlaying = true)&#10;    }&#10;&#10;    private fun prevInternal() {&#10;        val songs = PlayerRepository.playlist.value&#10;        if (songs.isEmpty()) return&#10;        val prevIdx = PlayerRepository.prevIndex()&#10;        PlayerRepository.setCurrentIndex(prevIdx)&#10;        prepareCurrent(startPlaying = true)&#10;    }&#10;&#10;    private fun seekInternal(position: Long) {&#10;        try {&#10;            mediaPlayer?.seekTo(position.toInt())&#10;            PlayerRepository.setPositionMs(position)&#10;        } catch (_: Throwable) { }&#10;    }&#10;&#10;    private fun updatePlaybackState(state: Int, position: Long = PlayerRepository.positionMs.value) {&#10;        val playbackState = PlaybackStateCompat.Builder()&#10;            .setActions(&#10;                PlaybackStateCompat.ACTION_PLAY or&#10;                        PlaybackStateCompat.ACTION_PAUSE or&#10;                        PlaybackStateCompat.ACTION_PLAY_PAUSE or&#10;                        PlaybackStateCompat.ACTION_SKIP_TO_NEXT or&#10;                        PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS or&#10;                        PlaybackStateCompat.ACTION_SEEK_TO&#10;            )&#10;            .setState(state, position, if (state == PlaybackStateCompat.STATE_PLAYING) 1f else 0f)&#10;            .build()&#10;        mediaSession?.setPlaybackState(playbackState)&#10;        updateNotificationFromSession()&#10;    }&#10;&#10;    private fun updateMetadata(title: String, artist: String) {&#10;        val metadata = MediaMetadataCompat.Builder()&#10;            .putString(MediaMetadataCompat.METADATA_KEY_TITLE, title)&#10;            .putString(MediaMetadataCompat.METADATA_KEY_ARTIST, artist)&#10;            .build()&#10;        mediaSession?.setMetadata(metadata)&#10;        updateNotificationFromSession()&#10;    }&#10;&#10;    private fun startPolling() {&#10;        pollJob?.cancel()&#10;        pollJob = scope.launch {&#10;            while (isActive) {&#10;                try {&#10;                    val pos = mediaPlayer?.currentPosition?.toLong() ?: 0L&#10;                    val dur = mediaPlayer?.duration?.toLong() ?: PlayerRepository.durationMs.value&#10;                    PlayerRepository.setPositionMs(pos)&#10;                    if (dur &gt; 0) PlayerRepository.setDurationMs(dur)&#10;                    // Throttle notification updates to ~500ms to keep progress timely without spamming&#10;                    val now = System.currentTimeMillis()&#10;                    if (now - lastNotificationUpdateTime &gt;= 500L) {&#10;                        try { updateNotificationFromSession() } catch (_: Throwable) {}&#10;                        lastNotificationUpdateTime = now&#10;                    }&#10;                } catch (_: Throwable) {}&#10;                delay(200)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startForegroundNotification() {&#10;        val title = mediaSession?.controller?.metadata?.getString(MediaMetadataCompat.METADATA_KEY_TITLE) ?: &quot;Playing&quot;&#10;        val artist = mediaSession?.controller?.metadata?.getString(MediaMetadataCompat.METADATA_KEY_ARTIST) ?: &quot;&quot;&#10;        val isPlaying = mediaSession?.controller?.playbackState?.state == PlaybackStateCompat.STATE_PLAYING&#10;        val token = mediaSession?.sessionToken&#10;        val prog = PlayerRepository.positionMs.value&#10;        val max = PlayerRepository.durationMs.value&#10;        val notification = PlayerNotificationManager.buildNotification(&#10;            this,&#10;            title,&#10;            artist,&#10;            isPlaying,&#10;            currentArtwork,&#10;            true,&#10;            true,&#10;            token,&#10;            progressMs = prog,&#10;            durationMs = max&#10;        )&#10;        startForeground(PlayerNotificationManager.NOTIFICATION_ID, notification)&#10;    }&#10;&#10;    private fun updateNotificationFromSession() {&#10;        val title = mediaSession?.controller?.metadata?.getString(MediaMetadataCompat.METADATA_KEY_TITLE) ?: &quot;&quot;&#10;        val artist = mediaSession?.controller?.metadata?.getString(MediaMetadataCompat.METADATA_KEY_ARTIST) ?: &quot;&quot;&#10;        val isPlaying = mediaSession?.controller?.playbackState?.state == PlaybackStateCompat.STATE_PLAYING&#10;        val token = mediaSession?.sessionToken&#10;        val prog = PlayerRepository.positionMs.value&#10;        val max = PlayerRepository.durationMs.value&#10;        val notification = PlayerNotificationManager.buildNotification(&#10;            this,&#10;            title,&#10;            artist,&#10;            isPlaying,&#10;            currentArtwork,&#10;            true,&#10;            true,&#10;            token,&#10;            progressMs = prog,&#10;            durationMs = max&#10;        )&#10;        PlayerNotificationManager.postNotification(this, notification)&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        pollJob?.cancel()&#10;        try { mediaPlayer?.release() } catch (_: Throwable) {}&#10;        try { currentArtwork?.recycle() } catch (_: Throwable) {}&#10;        mediaSession?.release()&#10;        PlayerNotificationManager.cancel(this)&#10;    }&#10;&#10;    // When the app task is removed from Recents, stop playback and the service to honor the user's intent&#10;    override fun onTaskRemoved(rootIntent: Intent?) {&#10;        super.onTaskRemoved(rootIntent)&#10;        try {&#10;            Log.d(TAG, &quot;onTaskRemoved: app task removed, stopping service and playback&quot;)&#10;            // stop foreground and remove notification&#10;            try { stopForeground(STOP_FOREGROUND_REMOVE) } catch (_: Throwable) {}&#10;            // ensure media resources are released and service stopped&#10;            try { mediaPlayer?.stop() } catch (_: Throwable) {}&#10;            try { mediaPlayer?.release() } catch (_: Throwable) {}&#10;            PlayerRepository.setIsPlaying(false)&#10;            stopSelf()&#10;        } catch (_: Throwable) {&#10;            // best-effort cleanup&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>